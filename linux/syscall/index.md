系统调用是受控的内核入口，借助于这一机制，进程可以请求内核以自己的名义去执行某些动作。以应用程序编程接口（API）的形式，内核提供有一系列服务供程序访问。这包括创建新进程、执行I/O，以及为进程间通信创建管道等。

从编程角度来看，系统调用与C语言函数的调用很相似。然而，在执行系统调用时，其幕后会历经诸多步骤。

- 1．应用程序通过调用C语言函数库中的外壳（wrapper）函数，来发起系统调用。

- 2．对系统调用中断处理例程（稍后介绍）来说，外壳函数必须保证所有的系统调用参数可用。通过堆栈，这些参数传入外壳

- 3．由于所有系统调用进入内核的方式相同，内核需要设法区分每个系统调用。为此，外壳函数会将系统调用编号复制到一个特殊的CPU寄存器（%eax）中

- 4．外壳函数执行一条中断机器指令（int 0x80），引发处理器从用户态切换到核心态，并执行系统中断0x80 (十进制数128)的中断矢量所指向的代码
  > 较新的x86-32硬件平台实现了sysenter指令，较之传统的int 0x80中断指令，sysenter指令进入内核的速度更快。2.6内核及glibc 2.3.2以后的版本都支持sysenter指令。

- 5．为响应中断0x80，内核会调用system_call()例程（位于汇编文件arch/i386/entry.S中）来处理这次中断，具体如下。
  
- 6．若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量errno。然后，外壳函数会返回到调用程序，并同时返回一个整型值，以表明系统调用是否成功。